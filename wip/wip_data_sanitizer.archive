#!/usr/bin/env python3
# =============================================================================
# data_sanitizer.py ‚Äî Metadata Normalization + Schema Safety Layer
# =============================================================================

import logging
from typing import Dict, Any, List

log = logging.getLogger(__name__)
# =============================================================================
# Block 2: Metadata Patch Layer (Safe Injection if missing)
# =============================================================================
def sanitize_metadata(data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Ensures metadata exists in the JSON structure with valid placeholders.
    """
    if "metadata" not in data or not isinstance(data["metadata"], dict):
        log.warning("üõë Missing or malformed metadata block. Injecting defaults.")
        data["metadata"] = {}

    meta = data["metadata"]
    
    meta.setdefault("sourceFilename", "unknown.dem")
    meta.setdefault("parserVersion", "v0.0.1")
    meta.setdefault("parsedAt", "N/A")
    meta.setdefault("rounds", [])
    meta.setdefault("tickrate", 64)
    meta.setdefault("mapName", "de_dust2")
    meta.setdefault("matchType", "competitive")
    meta.setdefault("duration", 0)
    meta.setdefault("players", [])

    return data
#BLOCK 3 enforce_schema_safety()
# =============================================================================
# Block 3: Top-Level Schema Normalizer (Events + PlayerStats + Chat)
# =============================================================================
def enforce_schema_safety(data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Ensures that essential top-level keys exist and are in valid format.
    Injects empty placeholders if missing to prevent downstream crashes.
    """
    if not isinstance(data, dict):
        raise ValueError("Input data must be a dictionary.")

    # Events
    if "events" not in data or not isinstance(data["events"], list):
        log.warning("‚ö†Ô∏è Missing or invalid 'events' key. Injecting empty list.")
        data["events"] = []

    # Chat
    if "chat" not in data or not isinstance(data["chat"], list):
        log.warning("‚ö†Ô∏è Missing or invalid 'chat' key. Injecting empty list.")
        data["chat"] = []

    # Player Stats
    if "playerStats" not in data or not isinstance(data["playerStats"], dict):
        log.warning("‚ö†Ô∏è Missing or invalid 'playerStats' key. Injecting empty dict.")
        data["playerStats"] = {}

    # Advanced Stats (optional, but common in ACS pipeline)
    if "advancedStats" not in data or not isinstance(data["advancedStats"], dict):
        log.info("üì¶ No advancedStats found, injecting empty.")
        data["advancedStats"] = {}

    # Scoreboard fallback
    if "scoreboard" not in data or not isinstance(data["scoreboard"], list):
        log.warning("‚ö†Ô∏è No scoreboard present. Injecting empty scoreboard.")
        data["scoreboard"] = []

    return data
# =============================================================================
# Block 4: Final Scoreboard Reconciliation reconcile_final_scoreboard() ‚Äî Scoreboard Injection Logic
# Purpose: Guarantees a complete final scoreboard, even if demo parsing failed or data is partial.
# =============================================================================
def reconcile_final_scoreboard(data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Ensures that all players listed in playerStats are represented in the scoreboard.
    Adds missing entries with placeholder stats (e.g., 0 KDA).
    """
    scoreboard = data.get("scoreboard", [])
    player_stats = data.get("playerStats", {})
    steam_ids_on_board = {entry.get("steamId") for entry in scoreboard if isinstance(entry, dict)}

    for steam_id, stats in player_stats.items():
        if steam_id not in steam_ids_on_board:
            log.info(f"üìà Adding missing player to scoreboard: {steam_id}")
            scoreboard.append({
                "steamId": steam_id,
                "name": stats.get("name", "Unknown"),
                "team": stats.get("team", "Unknown"),
                "kills": stats.get("kills", 0),
                "deaths": stats.get("deaths", 0),
                "assists": stats.get("assists", 0),
                "score": stats.get("score", 0),
                "adr": stats.get("adr", 0.0),
                "hsPercent": stats.get("hsPercent", 0.0),
                "utilityDamage": stats.get("utilityDamage", 0),
                "rank": stats.get("rank", "N/A"),
                "side": stats.get("side", "T"),
                "matchMvp": stats.get("matchMvp", 0)
            })

    data["scoreboard"] = scoreboard
    return data
#BLOCK 5
# =============================================================================
# Block 5: Debug Print Summary for Schema Gaps
# =============================================================================
def print_schema_summary(report: Dict[str, Any]) -> None:
    """
    Prints a simple debug-friendly summary of schema analysis.
    Used only during development and testing.
    """
    print("\nüß™ SCHEMA SUMMARY --------------------------")
    print(f"Missing Keys       : {report.get('missing_keys')}")
    print(f"Malformed Keys     : {report.get('malformed_keys')}")
    print(f"Gap Marker Count   : {report.get('gap_marker_count')}")
    print(f"Event Histogram    :")
    for k, v in report.get("event_type_histogram", {}).items():
        print(f" - {k}: {v}")
    print("--------------------------------------------\n")
#EOF 6 123 TLOC pzr1H 1045AM ET jul 26 2025




### old source below

#!/usr/bin/env python3
# =============================================================================
# data_sanitizer.py ‚Äî Patch & Validate JSON using .log file (Full Version)
# =============================================================================

import json
import re
from pathlib import Path
import argparse
import logging

log = logging.getLogger(__name__)


# =============================================================================
# Block 1: Log Parsing Layer
# =============================================================================
def parse_log_file(log_path):
    """
    Parse the .log file line-by-line into structured event dictionaries.
    Returns a list of parsed events with event 'type' and 'details'.
    """
    parsed_events = []
    log_path = Path(log_path)

    if not log_path.exists():
        raise FileNotFoundError(f"Log file not found: {log_path}")

    with log_path.open("r", encoding="utf-8") as file:
        for line in file:
            line = line.strip()
            match = re.match(r'^(events\.[A-Za-z0-9_]+)', line)
            if match:
                event_type = match.group(1)
                parsed_events.append({
                    "type": event_type,
                    "details": {"string": line, "gap_marker": True}  # <-- Injected marker for traceability
                })

    return parsed_events


# =============================================================================
# Block 2: JSON Structure Sanity Check + Event Reconciliation
# =============================================================================
def sanitize_json_with_log(json_data, log_events):
    """
    Compares and patches missing event types from the log into the parsed JSON.
    Returns: patched_json, list of inserted events, list of event types added.
    """
    if "events" not in json_data:
        log.error("‚ùå Missing 'events' block in JSON.")
        raise ValueError("Missing 'events' block in JSON.")

    if not isinstance(json_data["events"], list):
        log.error("‚ùå 'events' block must be a list.")
        raise ValueError("Invalid type for 'events'. Must be a list.")

    existing_types = set(event.get("type") for event in json_data["events"] if isinstance(event, dict))
    added_events = []
    added_types = set()

    for event in log_events:
        event_type = event.get("type")
        if event_type not in existing_types:
            added_events.append(event)
            added_types.add(event_type)

    if added_events:
        json_data["events"].extend(added_events)
        log.info(f"‚úÖ Injected {len(added_events)} new event(s) into JSON from .log.")

    return json_data, added_events, added_types


# =============================================================================
# EOB2 ‚Äî Event Reconciliation + Sanity Guard (TLOC: 76)
# =============================================================================
# =============================================================================
# Block 3: Metadata Schema Validator for playerStats, advancedStats, chat
# =============================================================================

from typing import Dict, Any

def sanitize_metadata(data: Dict[str, Any]) -> None:
    """
    Main hook for file_loader.py and other modules.
    Ensures playerStats, advancedStats, and chat blocks exist and are correct type.
    If missing or malformed, injects safe defaults and logs warnings.
    """
    if "playerStats" not in data:
        data["playerStats"] = {}
        log.warning("‚ö†Ô∏è Missing playerStats block. Injected empty dict.")

    elif not isinstance(data["playerStats"], dict):
        log.error("üí• playerStats must be a dict. Attempting to coerce.")
        try:
            coerced = {}
            for entry in data["playerStats"]:
                if isinstance(entry, dict) and "steamid" in entry:
                    coerced[entry["steamid"]] = entry
            data["playerStats"] = coerced
        except Exception as e:
            log.exception(f"üí• Failed to coerce playerStats: {e}")
            data["playerStats"] = {}

    if "advancedStats" not in data:
        data["advancedStats"] = {}
        log.info("‚ÑπÔ∏è Injected empty advancedStats block.")

    elif not isinstance(data["advancedStats"], dict):
        log.warning("‚ö†Ô∏è advancedStats malformed. Resetting to empty dict.")
        data["advancedStats"] = {}

    if "chat" not in data:
        data["chat"] = []
        log.info("‚ÑπÔ∏è Injected empty chat block.")

    elif not isinstance(data["chat"], list):
        log.warning("‚ö†Ô∏è chat malformed. Resetting to empty list.")
        data["chat"] = []

def enrich_and_validate(data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Optional secondary validator for enforcing schema defaults.
    Used when loading existing JSON that may be incomplete or malformed.
    """
    required_keys = ["playerStats", "advancedStats", "chat"]
    for key in required_keys:
        if key not in data:
            log.warning(f"‚ö†Ô∏è Key '{key}' missing. Injecting default.")
            data[key] = {} if "Stats" in key else []

    if not isinstance(data["playerStats"], dict):
        log.error("‚ùå playerStats must be dict. Overwriting.")
        data["playerStats"] = {}

    if not isinstance(data["advancedStats"], dict):
        log.error("‚ùå advancedStats must be dict. Overwriting.")
        data["advancedStats"] = {}

    if not isinstance(data["chat"], list):
        log.error("‚ùå chat must be list. Overwriting.")
        data["chat"] = []

    return data


# =============================================================================
# EOB3 ‚Äî Metadata Schema Validator Injected (TLOC: 144f)
# =============================================================================
# =============================================================================
# Block 4: Final Scoreboard Reconciliation (from rounds/summary logic)
# =============================================================================

def reconcile_final_scoreboard(data: Dict[str, Any]) -> None:
    """
    Ensures a final scoreboard block exists by inspecting roundSummary or events.
    Adds 'finalScoreboard' block to JSON if not present.
    """
    if "finalScoreboard" in data:
        log.debug("üü¢ finalScoreboard already present. Skipping injection.")
        return

    # Initialize fallback scoreboard
    scoreboard = {
        "team1": {"name": "Team 1", "score": 0},
        "team2": {"name": "Team 2", "score": 0}
    }

    rounds = data.get("roundSummary", [])
    if not isinstance(rounds, list):
        log.warning("‚ö†Ô∏è roundSummary not found or malformed. Skipping scoreboard.")
        return

    for r in rounds:
        winner = r.get("winningTeam")
        if winner == "team1":
            scoreboard["team1"]["score"] += 1
        elif winner == "team2":
            scoreboard["team2"]["score"] += 1

    # Attach to data
    data["finalScoreboard"] = scoreboard
    log.info(f"üìä Final Scoreboard Injected: {scoreboard}")

# =============================================================================
# Block 5: CLI Orchestration
# =============================================================================
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s")

    parser = argparse.ArgumentParser(description="Patch and validate JSON using demo log file")
    parser.add_argument("--json", required=True, help="Path to parsed demo JSON file")
    parser.add_argument("--log", required=True, help="Path to demo .log file")
    parser.add_argument("--out", help="Path to save the sanitized output JSON")

    args = parser.parse_args()

    try:
        with open(args.json, "r", encoding="utf-8") as f:
            data = json.load(f)

        log_events = parse_log_file(args.log)
        data, added_events, added_types = sanitize_json_with_log(data, log_events)
        sanitize_metadata(data)
        reconcile_final_scoreboard(data)

        if args.out:
            with open(args.out, "w", encoding="utf-8") as f:
                json.dump(data, f, indent=2)
            log.info(f"‚úÖ Sanitized JSON saved to {args.out}")
        else:
            print(json.dumps(data, indent=2))

    except Exception as e:
        log.exception(f"üí• Error during sanitation: {e}")

# =============================================================================
# EXPORT:: enforce_schema_safety (required by file_loader.py)
# =============================================================================
def enforce_schema_safety(data: dict) -> dict:
    """
    Stub for schema safety ‚Äî returns data unmodified if no rules defined.
    """
    return data


# =============================================================================
# EOF ‚Äî data_sanitizer.py v1.0 | LOC: ~242
# =============================================================================
# ‚úî Functions Implemented:
#   - parse_log_file()
#   - sanitize_json_with_log()
#   - sanitize_metadata()
#   - enrich_and_validate()
#   - reconcile_final_scoreboard()
#   - CLI orchestration block (__main__)
#
# ‚úî Structural Guarantees:
#   - All key blocks (events, playerStats, advancedStats, chat) enforced
#   - FinalScoreboard derived from roundSummary
#   - .log event injection for reconciliation
#
# ‚úî Logging + Fault Tolerance:
#   - Logging at WARN/INFO/ERROR level
#   - Fallback coercion logic for malformed dicts
#
# üîç gap_marker: True added to injected .log events
# =============================================================================
# EOB5 ‚Äî CLI Bootstrap + EOF Marker
# =============================================================================
#253 LOC pzr1h